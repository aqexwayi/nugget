- Add (list) or equivalent, and (length)
- Integrate them to tail call example - why is'nt that one overflowing memory and/or crashing?
  What does length print as that program is left to run?
- closure issue when setting a non-lambda variable, eg:
    (set! x #t) ; (+ 2 (* 3 4)))
    (display x);)
  see also: adder.scm
- Get other programs under 'tests' working
- Add numeric support - integers or doubles (or both), and numeric operations
- WRT set! support, and mutable variables:
  - set aggressive GC, and see if there are any problems with data being lost
    need to do this with a more complicated example, though
- define - can this with with mutable variable elimination, or does it require C globals (per cboyer)? Are there special cases for top-level? If cells can be used for vars, do we need to keep track of the roots to prevent invalid GC? lots of questions here
- TBD: Can there be a lambda reference that is not a closure or a direct call?
- interesting (but probably not a big deal):
 (begin (let ((x #f)) (set! x (+ 2 (* 3 4))) (display x)))
 after desugar:
 ((lambda (x) (set! x (+ 2 (* 3 4)))) #f)
 was the begin optimized away?
- Question about closures and continuations:
 Presumably every function will recieve a closure. Do we have to differentiate between continuation (which every
 function must have) and closure (which can be empty if no fv)? right now the MTA runtime combines the two by
 having an fn argument to each closure. Is that OK?
- Add eval support. Will probably also require apply, read, etc. will probably be necessary to write interpreter in CPS style - see notes.
- look at chicken internals doc - is alpha conversion needed to prevent name collisions during compilation?
- Just a thought: if this ever became self-hosting, could distribute compiled C files
