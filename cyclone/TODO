- closures are not being compiled correctly

 need to figure out how exactly to compute closures (IE, mclosure statements) in compiled C code.
 It seems each function should receive a closure, the code that inserts (closure _) just seems wrong.
 There is a clue in that the fix in the if example is to load (self->elt1) into the closure, sort of like
 how trans.scm loads (map cc new-free-vars) into the %closure code.

 Still a bit fuzzy on where/how exactly to generate each closure, though. maybe take a look at 90-min-scc
 to see if it is of any help at all.

 Presumably every function will recieve a closure. Do we have to differentiate between continuation (which every
 function must have) and closure (which can be empty if no fv)? right now the MTA runtime combines the two by
 having an fn argument to each closure.

IMPLEMENTATION NOTES:

 - cgen is keeping track of free vars in the wrong way, they are not equivalent to function arguments, but rather are uncovered during closure conversion by scanning for them. NEED TO FIGURE OUT HOW TO READ THESE PROPERLY IN CGEN - once that is done, everything else should fall into place
 - if there are no free variables, a function call call into its continuation using return_check.
 - if there are free variables, a closure must be used to pass them to the continuation. mclosure must be used to create it, and a return_funcall would be used to call into the next continuation

-------------------------------------------------------------------------------------------
Previous notes:
Bottom line is that cgen is not computing them correctly

Also, with call/cc changes, the if example has a bad closure:
static void __lambda_3(object self_739, object x) {
  
mclosure1(c_7337, __lambda_2,((closure1)self_739)->elt1);
//mclosure1(c_7337, __lambda_2,x);

 Seems there are many cases where extra args should not be added to a closure. see call-cc-debug.c

 however, actual bug is an extra arg in lambda_5:

 should be: mclosure2(c_7321, __lambda_4, k, f); // bug to include all args??
 not: mclosure3(c_7321, __lambda_4,self_734, k, f); // bug to include all args??

- Add code to generate return_funcall, funcall, and return_check macros. Ideally also generate funcall code at end of GC (maybe call into a macro or something, and can then generate that code along with the others).
- Get other programs under 'tests' working
- Add numeric support - integers or doubles (or both), and numeric operations
- Integrate C keywords and name mangling, to prevent generating C identifiers that are
  keywords
- WRT set! support, and mutable variables:
  - set aggressive GC, and see if there are any problems with data being lost
    need to do this with a more complicated example, though

- This seems like a bug, r_733 should not have been added to this closure:
  in closure-1.scm:

    static void __lambda_2(object r_733) {
        mclosure1(c_7310, __lambda_1,r_733);
- What other examples do not work yet? go through the list

- define - can this with with mutable variable elimination, or does it require C globals (per cboyer)? Are there special cases for top-level? If cells can be uased for vars, do we need to keep track of the roots to prevent invalid GC? lots of questions here

- TBD: Can there be a lambda reference that is not a closure or a direct call?
- interesting (but probably not a big deal):
 (begin (let ((x #f)) (set! x (+ 2 (* 3 4))) (display x)))
 after desugar:
 ((lambda (x) (set! x (+ 2 (* 3 4)))) #f)

 was the begin optimized away?

- Just a thought: if this ever became self-hosting, could distribute compiled C files
