- Look into set! support, and mutable variables.
  - try to generate code for closures generated by set! example
    
    in the generated code, probably want self to be the first arg, and then append each of the args (EG: set-cell!) to the call. EG: set-cell maps to r2.

  - look into assignment conversion for using cons cells instead of globals to hold variables.
  - set aggressive GC, and see if there are any problems with data being lost

- This is a bug, r_733 should not have been added to this closure:

    static void __lambda_2(object r_733) {
        mclosure1(c_7310, __lambda_1,r_733);
- What other examples do not work yet? go through the list

- TBD: Can there be a lambda reference that is not a closure or a direct call?
- interesting (but probably not a big deal):
 (begin (let ((x #f)) (set! x (+ 2 (* 3 4))) (display x)))
 after desugar:
 ((lambda (x) (set! x (+ 2 (* 3 4)))) #f)

 was the begin optimized away?

- Just a thought: if this ever became self-hosting, could distribute compiled C files
