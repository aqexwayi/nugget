- Pass port along with emit procedures, to allow the scheme code to write to an output file (IE, c file)
- Add "autogenerated by cyclone" header (w/version) to the top of generated c files
- Get rid of cyc script and integrate this into compiler. Add -v option (version), -d (debug), -h (help)
- closure issue when setting a non-lambda variable, eg:
    (set! x #t) ; (+ 2 (* 3 4)))
    (display x);)
  see also: adder.scm
- Get other programs under 'tests' working. Will need to add numeric comparison ops
- Add more numeric support, and doubles 
- WRT set! support, and mutable variables:
  - set aggressive GC, and see if there are any problems with data being lost
    need to do this with a more complicated example, though
- Could add other scheme library functions to the compiled prog just
  like call/cc. alternatively could compile them into a library somewhere
  for inclusion.
- define - can this with with mutable variable elimination, or does it require C globals (per cboyer)? Are there special cases for top-level? If cells can be used for vars, do we need to keep track of the roots to prevent invalid GC? lots of questions here
- TBD: Can there be a lambda reference that is not a closure or a direct call?
- interesting (but probably not a big deal):
 (begin (let ((x #f)) (set! x (+ 2 (* 3 4))) (display x)))
 after desugar:
 ((lambda (x) (set! x (+ 2 (* 3 4)))) #f)
 was the begin optimized away?
- Question about closures and continuations:
 Presumably every function will recieve a closure. Do we have to differentiate between continuation (which every
 function must have) and closure (which can be empty if no fv)? right now the MTA runtime combines the two by
 having an fn argument to each closure. Is that OK?
- Add eval support. Will probably also require apply, read, etc. will probably be necessary to write interpreter in CPS style - see notes. One idea - parse and compile input to scheme expressions, then call apply. could that work? should also see chapter 6 of lisp in small pieces.
- may be necessary to specify arity of functions in call to apply
- look at chicken internals doc - is alpha conversion needed to prevent name collisions during compilation?
- Just a thought: if this ever became self-hosting, could distribute compiled C files
            
     
